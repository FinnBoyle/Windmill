#include "orientation_stepper.h"
#include <Arduino.h>
#include <math.h>
#define PI 3.14159265
OrientationStepper::OrientationStepper(Stepper* stepper, OrientationPID* pid,  int pidInterval, int bufferSize, double rotationTolerance) {
  m_stepper = stepper;
  m_pid = pid;
  m_state = OFF;
  m_steps = 0;
  m_rpm = 20;
  m_fakeWindDir = 180;
  m_rotation = 0;
  m_stepper->setSpeed(m_rpm);
  m_lastMove = 0;
  m_rotationTolerance = rotationTolerance;
  m_pidInterval = pidInterval;
  m_bufferSize = bufferSize;
  m_pidErrorHistory = new float[m_bufferSize];
  m_rotationHistory = new float[m_bufferSize];
  m_bufferIndex = 0;

  //generated for MOVE_STEPS_AND_BACK
  m_moveBackSteps = 0;
  m_moveDirection = 0;
  
  //used for AUTO_NO_HELP
  rotationDegrees = 360;
  rotationAmount = 40;
  rotationIncrement = rotationDegrees / rotationAmount;
  rotationKeys = new double[(int)rotationIncrement];
  rotationVolts = new double[(int)rotationIncrement];
  maxVoltageRotation = 0;
  rotationCounter = 0;

  //used for AUTO_FOUNDATIONS
  currentRotation = 0; //current rotation angle
  optimalRotation = 0; //optimal rotation angle found
  recordedPower = new double[9]; //recorded power at each step in the 360
  currentIndex = 0; //to keep track of where to insert the next power value

  //used for AUTO_FINISHINGS
  detectedVoltages = new double[9];
  rotations = new double[9];
  totalRotation = 0.0;
  maxRotation = 360.0;
  rotationStep = 40.0;
  stepCount = 0;

  //AUTO_FULL
  bestRotation = 0.0;
  maxVoltage = -1.0;
  rotation_step = 40.0;
  currRotation = 0.0;
}

// double OrientationStepper::fakeVoltage() {
//   return 1.5 * exp(-0.0001 * pow((m_rotation - m_fakeWindDir), 2));
// }

double OrientationStepper::fakeVoltage() {
  return sin(m_rotation/57.3)/2.0;
}


double normalRange(double rotation) {
    double normalVal = fmod(rotation, 360);
    if (normalVal < 0) {
        normalVal += 360;
    }
    
    return normalVal;
}

void OrientationStepper::update(double volts) {
  if (m_state == CLOCKWISE_AUTO) {
    unsigned long now = millis();
    if (now - m_lastMove > 20) {
      m_lastMove = now;
      int steps = calculateSteps(20);
      m_stepper->step(steps);
    }
  } else if (m_state == ANTI_CLOCKWISE_AUTO) {
    unsigned long now = millis();
    if (now - m_lastMove > 50) {
      m_lastMove = now;
      int steps = calculateSteps(-20);
      m_stepper->step(steps);
    }
  }else if (m_state == PID_FAKE) {
    unsigned long now = millis();
    //every 2s send an initialization request or turbine metrics to ESP8266
    if (now - m_lastMove > m_pidInterval) {
      m_lastMove = now;
      double voltage = fakeVoltage();
      double change = m_pid->compute(voltage,m_rotation);
      // Serial.println(change);
      m_pidErrorHistory[m_bufferIndex] = change;
      //remove overflow from rotation threshold
      m_rotationHistory[m_bufferIndex] = normalRange(m_rotation);
      m_bufferIndex++;
      m_stepper->step(calculateSteps(change));
    }
  } else if (m_state == PID) {
    unsigned long now = millis();
    //every 2s send an initialization request or turbine metrics to ESP8266
    if (now - m_lastMove > m_pidInterval) {
      m_lastMove = now;
      double voltage = volts;
      double change = m_pid->compute(voltage,m_rotation);
      // Serial.println(change);
      m_pidErrorHistory[m_bufferIndex] = change;
      //remove overflow from rotation threshold
      m_rotationHistory[m_bufferIndex] = normalRange(m_rotation);
      m_bufferIndex++;
      m_stepper->step(calculateSteps(change));
    }
  } else if (m_state == CLOCKWISE_STEPS) {
    if (m_steps > 0) {
      m_stepper->step(calculateSteps(m_steps * 1.8));
      m_steps = 0;
    }
  } else if (m_state == ANTI_CLOCKWISE_STEPS) {
    if (m_steps > 0) {
      m_stepper->step(calculateSteps(-m_steps * 1.8));
      m_steps = 0;
    }
  } else if (m_state == MOVE_STEPS_AND_BACK) { //simple function generated by chatgpt
    if(m_steps > 0) {
      m_stepper->step(calculateSteps(m_steps * 1.8));
      delay(1000);
      m_stepper->step(calculateSteps(-m_steps * 1.8));
      m_steps = 0;
    }
  } else if (m_state == AUTO_NO_HELP) { //completely done by me
    unsigned long now = millis();
    int steps = 0;

    //continue to rotate until a 360 has been performed
    if (maxVoltageRotation < rotationDegrees) {
      if (now - m_lastMove > 2000) {
        m_lastMove = now;
        
        //capture the current voltage detected and rotation amount
        double voltage = volts;
        rotationKeys[rotationCounter] = maxVoltageRotation;
        rotationVolts[rotationCounter] = voltage;
        
        //rotate a specified distance
        steps = calculateSteps(rotationAmount);
        m_stepper->step(steps);

        //update variables for next increment
        maxVoltageRotation += rotationAmount;
        rotationCounter++;
      }
    } else if (maxVoltageRotation >= rotationDegrees) {
      //return to highest recorded voltage rotation
      delay(1000);
      double highestVoltage = 0;
      double returnRotation = 0;
      //discover maximum voltage detected in the full rotation
      //capture the location in the array of the maximum voltage detected
      for (int i = 0; i < rotationIncrement; i++) {
        if (rotationVolts[i] > highestVoltage) {
          //capture the highest recorded voltage, set return rotation
          highestVoltage = rotationVolts[i];
          returnRotation = rotationKeys[i];
        }
      }
      //Rotate to location of highest voltage generation
      steps = calculateSteps(-returnRotation);
      m_stepper->step(steps);

      //simulate real windmill operation (utilising the strongest wind source for real world work)
      delay(5000);

      //reset variables and start function again
      for (int i = 0; i < rotationIncrement; i++) {
        rotationKeys[i] = 0;
        rotationVolts[i] = 0;
      }
      maxVoltageRotation = 0;
      rotationCounter = 0;
    }
  } else if (m_state == AUTO_FOUNDATIONS) { //begun by ChatGPT, finished by me
    unsigned long now = millis();

    if (currentRotation >= 360) {
      //find optimal rotation angle after a 360
      double maxPower = recordedPower[0];
      int maxIndex = 0;
      for(int i = 0; i < 9; i++) {
        if(recordedPower[i] > maxPower) {
          maxPower = recordedPower[i];
          maxIndex = i;
        }
      }

      optimalRotation = maxIndex * 40; //40 degree increment

      //move to the optimal rotation
      currentRotation = optimalRotation;
      m_stepper->step(calculateSteps(-currentRotation));
      delay(5000);

      //clear recorded data and reset current rotation to start the process again
      for (int i = 0; i < 9; i++) {
        recordedPower[i] = 0;
      }
      currentIndex = 0;
      currentRotation = 0;
    } else {
      if (now - m_lastMove > 2000) {
        //rotate the windmill by 40 degrees
        m_stepper->step(calculateSteps(40));
        currentRotation += 40;

        // ensure rotation is within 0 and 360 degrees
        if(currentRotation > 360) {
          currentRotation -= 360; 
        }

        //record the power generation at this rotation angle
        double voltage = volts;
        if(currentIndex < 9) {
          recordedPower[currentIndex++] = volts;
        }
      }
    }
  } else if (m_state == AUTO_FINISHINGS) { //begun by me, finished by ChatGPT
    unsigned long now = millis();
    
    if(totalRotation < maxRotation) {
      if(now - m_lastMove > 2000) {
        m_lastMove = now;

        //store detected windmill generated voltage
        double voltage = volts;
        detectedVoltages[stepCount] = voltage;
        rotations[stepCount] = totalRotation;

        m_stepper->step(calculateSteps(rotationStep));

        totalRotation += rotationStep;
        stepCount++;
      }
    } else {
      //determine maximum voltage rotation
      double maxVoltage = detectedVoltages[0];
      int maxIndex = 0;
      for (int i = 1; i < stepCount; ++i) {
        if (detectedVoltages[i] > maxVoltage) {
          maxVoltage = detectedVoltages[i];
          maxIndex = i;
        }
      }
      double bestRotation = rotations[maxIndex];

      //rotate back to best voltage
      m_stepper->step(calculateSteps(-bestRotation));

      delay(5000);

      //clear variables
      for (int i = 0; i < 9; i++) {
        detectedVoltages[i] = 0.0;
        rotations[i] = 0.0;
      }
      totalRotation = 0.0;
      stepCount = 0;
      }
  } else if (m_state == AUTO_FULL) { //completely done by ChatGPT
    unsigned long now = millis();

    if (currRotation < 360.0) {
      if (now - m_lastMove > 2000) {
        m_stepper->step(calculateSteps(rotation_step)); //40 degree steps

        double voltage = volts;

        if (voltage > maxVoltage) {
          maxVoltage = voltage;
          bestRotation = currRotation;
        }

        currRotation += rotation_step;
        m_lastMove = now;
      }
    } else {
      //once optimal rotation found, maintain it
      m_stepper->step(calculateSteps(bestRotation));

      delay(5000);

      //reset variables
      maxVoltage = -1.0;
      currRotation = 0.0;
    }
  }
}

StepperState OrientationStepper::getState() {
  return m_state;
}

void OrientationStepper::setState(int state) {
  m_state = state;
}

void OrientationStepper::setRPM(int rpm) {
  if (rpm != m_rpm) {
    m_rpm = rpm;

    m_stepper->setSpeed(m_rpm);
  }
}

void OrientationStepper::addSteps(int steps) {
  m_steps += steps;
}


int OrientationStepper::calculateSteps(double degrees) {
  int steps = 0;
  double old_rotation = m_rotation;
  // degrees = 50
  //If new rotation exceeds  (360 + m_rotationTolerance) degrees go the same position within 0-(360 + m_rotationTolerance) range
  if ((m_rotation + degrees) > (360 + m_rotationTolerance)) {
    double overshoot = m_rotation + degrees - 360;  //e.g. degrees over 360
    m_rotation = overshoot;                      //rotation is the the same rotation as just the degrees over 360
    steps -= (old_rotation - overshoot) / 1.8;
    //If new rotation is less than  (360 + m_rotationTolerance) degrees go the  same position within 0-(360 + m_rotationTolerance) range
  } else if ((m_rotation + degrees) < (0 - m_rotationTolerance)) {
    double overshoot = m_rotation + degrees;
    m_rotation =  360 + overshoot;
    steps += (m_rotation - old_rotation) / 1.8;
    //Otherwise move normally
  } else {
    steps = degrees / 1.8;
    m_rotation = m_rotation + degrees;
  }
  if (steps == 0 && degrees > 0) {
    m_rotation = m_rotation + 1.8;
    return 1;
  }
  return steps;
}

  double OrientationStepper::getRotation() {
    return m_rotation;
  }

 void OrientationStepper::resetBuffers() {
   m_bufferIndex = 0;
 }
  bool OrientationStepper::bufferFull() {
    return m_bufferIndex >= m_bufferSize;
  }
  float* OrientationStepper::getErrorHistory() {
    return m_pidErrorHistory;
  }
  float* OrientationStepper::getRotationHistory() {
    return m_rotationHistory;
  }
  int OrientationStepper::getInterval() {
    return m_pidInterval;
  }
